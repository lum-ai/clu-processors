<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lum.clu.odin.mention API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lum.clu.odin.mention</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
from __future__ import annotations
from pydantic import BaseModel, Field
from lum.clu.processors.document import Document
from lum.clu.processors.sentence import Sentence
from lum.clu.processors.interval import Interval
from lum.clu.odin.synpath import SynPath
import re
import typing


__all__ = [&#34;Mention&#34;, &#34;TextBoundMention&#34;, &#34;RelationMention&#34;, &#34;EventMention&#34;, &#34;CrossSentenceMention&#34;]

# MentionTypes = typing.Union[TextBoundMention, EventMention, RelationMention, CrossSentenceMention]

class Mention(BaseModel):

  Paths: typing.ClassVar[typing.TypeAlias] = dict[str, dict[&#34;Mention&#34;, SynPath]]

  Arguments: typing.ClassVar[typing.TypeAlias] = dict[str, list[&#34;Mention&#34;]]
  # FIXME: add validation that this is non-empty?
  labels: list[str] = Field(description=&#34;A sequence of labels for this mention. The first label in the sequence is considered the default.&#34;)
  # alias=&#34;tokenInterval&#34;, 
  token_interval: Interval  = Field(description=&#34;The interval of token indicess that form this mention.&#34;)
  # alias=&#34;sentence&#34;, 
  sentence_index: int = Field(description=&#34;The index of the sentence where this mention occurs.&#34;)

  document: Document = Field(description=&#34;The document where this mention occurs&#34;)

  keep: bool = Field(default=True, description=&#34;Should we report this mention at the end?&#34;)

  arguments: typing.Optional[Mention.Arguments] = Field(default=None, description=&#34;A map from argument name to a sequence of mentions. The value of the map is a sequence because there are events that can have several arguments with the same name. For example, in the biodomain, Binding may have several themes.&#34;)

  paths: typing.Optional[Paths] = Field(default=None, description=&#34;Graph traversal leading to each argument&#34;)
  # alias=&#34;foundBy&#34;
  found_by: str = Field(default=&#34;unknown&#34;, description=&#34;The name of the rule that produced this mention&#34;)

  def copy(
    self,
    maybe_labels: typing.Optional[list[str]] = None,
    maybe_token_interval: typing.Optional[Interval] = None,
    maybe_sentence_index: typing.Optional[int] = None,
    maybe_document: typing.Optional[Document] = None,
    maybe_keep: typing.Optional[bool] = None,
    maybe_arguments: typing.Optional[Mention.Arguments] = None,
    maybe_paths: typing.Optional[Mention.Paths] = None,
    maybe_found_by: typing.Optional[str] = None,
  ) -&gt; Mention:
    return Mention(
      labels = maybe_labels or self.labels,
      token_interval = maybe_token_interval or self.token_interval,
      sentence_index = maybe_sentence_index or self.sentence_index,
      document = maybe_document or self.document,
      keep = maybe_keep or self.keep,
      arguments = maybe_arguments or self.arguments,
      paths = maybe_paths or self.paths,
      found_by = maybe_found_by or self.found_by
    )

  @property
  def label(self) -&gt; str:
    &#34;&#34;&#34;the first label for the mention&#34;&#34;&#34;
    return self.labels[0]
    
  @property
  def start(self) -&gt; int:
    &#34;&#34;&#34;index of the first token in the mention&#34;&#34;&#34;
    return self.token_interval.start

  @property
  def end(self) -&gt; int:
    &#34;&#34;&#34;one after the last token in the mention&#34;&#34;&#34;
    return self.token_interval.end
  
  @property
  def sentence_obj(self) -&gt; Sentence:
    return self.document.sentences[self.sentence_index]

  @property
  def sentenceObj(self) -&gt; Sentence:
    self.sentence_obj

  @property
  def start_offset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention beginning&#34;&#34;&#34;
    return self.sentence_obj.start_offsets[self.start]

  @property
  def startOffset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention beginning&#34;&#34;&#34;
    return self.start_offset 

  @property
  def char_start_offset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention beginning&#34;&#34;&#34;
    return self.start_offset 
  
  @property
  def end_offset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention end&#34;&#34;&#34;
    return self.sentence_obj.end_offsets[self.end - 1]

  @property
  def endOffset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention end&#34;&#34;&#34;
    return self.end_offset 

  @property
  def char_end_offset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention end&#34;&#34;&#34;
    return self.end_offset 
  
  @property
  def is_valid(self) -&gt; bool:
    &#34;&#34;&#34;returns true if this is a valid mention&#34;&#34;&#34;
    return True

  @property
  def isValid(self) -&gt; bool:
    &#34;&#34;&#34;returns true if this is a valid mention&#34;&#34;&#34;
    return self.is_valid

  def matches(self, label_or_pattern: typing.Union[str, re.Pattern]) -&gt; bool:
    &#34;&#34;&#34;returns true if `label_or_pattern` matches any of the mention labels&#34;&#34;&#34;
    if isinstance(label_or_pattern, str):
      return label_or_pattern in self.labels
    elif isinstance(label_or_pattern, re.Pattern):
      patt = label_or_pattern
      return True if any(re.match(patt, lbl) != None for lbl in self.labels) else False
    return False

  @property
  def raw(self) -&gt; list[str]:
    &#34;&#34;&#34;returns all raw (original, no processing applied) tokens in mention&#34;&#34;&#34;
    return self.sentence_obj.raw[self.start:self.end]

  @property
  def words(self) -&gt; list[str]:
    &#34;&#34;&#34;returns all tokens in mention&#34;&#34;&#34;
    return self.sentence_obj.words[self.start:self.end]

  @property
  def tags(self) -&gt; typing.Optional[list[str]]:
    &#34;&#34;&#34;returns all tags in mention&#34;&#34;&#34;
    if self.sentence_obj.tags:
      return self.sentence_obj.tags[self.start:self.end]
    return None
  
  @property
  def lemmas(self) -&gt; typing.Optional[list[str]]:
    &#34;&#34;&#34;returns all lemmas in mention&#34;&#34;&#34;
    if self.sentence_obj.lemmas:
      return self.sentence_obj.lemmas[self.start:self.end]
    return None
  
  @property
  def entities(self) -&gt; typing.Optional[list[str]]:
    &#34;&#34;&#34;returns all entities in mention&#34;&#34;&#34;
    if self.sentence_obj.entities:
      return self.sentence_obj.entities[self.start:self.end]
    return None
  
  @property
  def norms(self) -&gt; typing.Optional[list[str]]:
    &#34;&#34;&#34;returns all norms in mention&#34;&#34;&#34;
    if self.sentence_obj.norms:
      return self.sentence_obj.norms[self.start:self.end]
    return None
  
  @property
  def chunks(self) -&gt; typing.Optional[list[str]]:
    &#34;&#34;&#34;returns all chunks in mention&#34;&#34;&#34;
    if self.sentence_obj.chunks:
      return self.sentence_obj.chunks[self.start:self.end]
    return None

  @property
  def text(self) -&gt; str:
    &#34;&#34;&#34;returns a string that contains the mention&#34;&#34;&#34;
    _text = self.document.text
    if _text is not None:
      return _text[self.start_offset:self.end_offset]
    # FIXME: this can be improved
    else:
      return &#34; &#34;.join(self.raw[self.start:self.end])

  # /** returns a string that contains the mention */
  # def text: String = document.text match {
  #   case Some(txt) =&gt; txt.slice(startOffset, endOffset)
  #   case None =&gt;
  #     // try to reconstruct the sentence using the character offsets
  #     val bits = raw.head +: tokenInterval.tail.map { i =&gt;
  #       val spaces = &#34; &#34; * (sentenceObj.startOffsets(i) - sentenceObj.endOffsets(i - 1))
  #       val rawWord = sentenceObj.raw(i)
  #       spaces + rawWord
  #     }
  #     bits.mkString
  # }
    
  # /** returns all syntactic heads */
  # def synHeads: Seq[Int] = sentenceObj.dependencies match {
  #   case Some(deps) =&gt; DependencyUtils.findHeads(tokenInterval, deps)
  #   case None =&gt; Nil
  # }

  # /** returns the minimum distance to a root node for dependencies within the token interval */
  # def distToRootOpt: Option[Int] = sentenceObj.dependencies.flatMap { deps =&gt;
  #   // Note that
  #   // Double.MaxValue.toInt == Int.MaxValue
  #   // Double.PositiveInfinity.toInt == Int.MaxValue
  #   DependencyUtils.distToRootOpt(tokenInterval, deps).map(_.toInt)
  # }

  # /** returns the syntactic head of `mention`  */
  # def synHead: Option[Int] = synHeads.lastOption

  # /** returns head token */
  # def synHeadWord: Option[String] = synHead.map(i =&gt; sentenceObj.words(i))

  # /** returns head pos tag */
  # def synHeadTag: Option[String] = synHead.flatMap(i =&gt; sentenceObj.tags.map(_(i)))

  # /** returns head lemma */
  # def synHeadLemma: Option[String] = synHead.flatMap(i =&gt; sentenceObj.lemmas.map(_(i)))

  # /** returns all semantic heads */
  # def semHeads: Seq[Int] = DependencyUtils.findHeadsStrict(tokenInterval, sentenceObj)

  # /** returns the syntactic head of `mention`  */
  # def semHead: Option[Int] = semHeads.lastOption

  # /** returns head token */
  # def semHeadWord: Option[String] = semHead.map(i =&gt; sentenceObj.words(i))

  # /** returns head pos tag */
  # def semHeadTag: Option[String] = semHead.flatMap(i =&gt; sentenceObj.tags.map(_(i)))

  # /** returns head lemma */
  # def semHeadLemma: Option[String] = semHead.flatMap(i =&gt; sentenceObj.lemmas.map(_(i)))


  # override def canEqual(a: Any) = a.isInstanceOf[Mention]

  # override def equals(that: Any): Boolean = that match {
  #   case that: Mention =&gt; that.canEqual(this) &amp;&amp; this.hashCode == that.hashCode
  #   case _ =&gt; false
  # }

  # def compare(that: Mention): Int = {
  #   require(this.document == that.document,
  #     &#34;can&#39;t compare mentions if they belong to different documents&#34;)
  #   if (this.sentence &lt; that.sentence) -1
  #   else if (this.sentence &gt; that.sentence) 1
  #   else this.tokenInterval compare that.tokenInterval
  # }

  # def precedes(that: Mention): Boolean = this.compare(that) &lt; 0

# class Mention(BaseModel):
    
#     TBM: typing.ClassVar[str] = &#34;TextBoundMention&#34;
#     EM: typing.ClassVar[str] = &#34;EventMention&#34;
#     RM: typing.ClassVar[str] = &#34;RelationMention&#34;

#     &#34;&#34;&#34;
#     A labeled span of text.  Used to model textual mentions of events, relations, and entities.

#     Parameters
#     ----------
#     token_interval : Interval
#         The span of the Mention represented as an Interval.
#     sentence : int
#         The sentence index that contains the Mention.
#     document : Document
#         The Document in which the Mention was found.
#     foundBy : str
#         The Odin IE rule that produced this Mention.
#     label : str
#         The label most closely associated with this span.  Usually the lowest hyponym of &#34;labels&#34;.
#     labels: list
#         The list of labels associated with this span.
#     trigger: dict or None
#         dict of JSON for Mention&#39;s trigger (event predicate or word(s) signaling the Mention).
#     arguments: dict or None
#         dict of JSON for Mention&#39;s arguments.
#     paths: dict or None
#         dict of JSON encoding the syntactic paths linking a Mention&#39;s arguments to its trigger (applies to Mentions produces from `type:&#34;dependency&#34;` rules).
#     doc_id: str or None
#         the id of the document

#     Attributes
#     ----------
#     tokenInterval: processors.ds.Interval
#         An `Interval` encoding the `start` and `end` of the `Mention`.
#     start : int
#         The token index that starts the `Mention`.
#     end : int
#         The token index that marks the end of the Mention (exclusive).
#     sentenceObj : processors.ds.Sentence
#         Pointer to the `Sentence` instance containing the `Mention`.
#     characterStartOffset: int
#         The index of the character that starts the `Mention`.
#     characterEndOffset: int
#         The index of the character that ends the `Mention`.
#     type: Mention.TBM or Mention.EM or Mention.RM
#         The type of the `Mention`.

#     See Also
#     --------

#     [`Odin` manual](https://arxiv.org/abs/1509.07513)

#     Methods
#     -------
#     matches(label_pattern)
#         Test if the provided pattern, `label_pattern`, matches any element in `Mention.labels`.

#     overlaps(other)
#         Test whether other (token index or Mention) overlaps with span of this Mention.

#     copy(**kwargs)
#         Copy constructor for this Mention.

#     words()
#         Words for this Mention&#39;s span.

#     tags()
#         Part of speech for this Mention&#39;s span.

#     lemmas()
#         Lemmas for this Mention&#39;s span.

#     _chunks()
#         chunk labels for this Mention&#39;s span.

#     _entities()
#         NE labels for this Mention&#39;s span.
#     &#34;&#34;&#34;

    # def __init__(self,
    #             token_interval,
    #             sentence,
    #             document,
    #             foundBy,
    #             label,
    #             labels=None,
    #             trigger=None,
    #             arguments=None,
    #             paths=None,
    #             keep=True,
    #             doc_id=None):

    #     NLPDatum.__init__(self)
    #     self.label = label
    #     self.labels = labels if labels else [self.label]
    #     self.tokenInterval = token_interval
    #     self.start = self.tokenInterval.start
    #     self.end = self.tokenInterval.end
    #     self.document = document
    #     self._doc_id = doc_id or hash(self.document)
    #     self.sentence = sentence
    #     if trigger:
    #         # NOTE: doc id is not stored for trigger&#39;s json,
    #         # as it is assumed to be contained in the same document as its parent
    #         trigger.update({&#34;document&#34;: self._doc_id})
    #         self.trigger = Mention.load_from_JSON(trigger, self._to_document_map())
    #     else:
    #         self.trigger = None
    #     # unpack args
    #     self.arguments = {role:[Mention.load_from_JSON(a, self._to_document_map()) for a in args] for (role, args) in arguments.items()} if arguments else None
    #     self.paths = paths
    #     self.keep = keep
    #     self.foundBy = foundBy
    #     # other
    #     self.sentenceObj = self.document.sentences[self.sentence]
    #     self.text = &#34; &#34;.join(self.sentenceObj.words[self.start:self.end])
    #     # recover offsets
    #     self.characterStartOffset = self.sentenceObj.startOffsets[self.tokenInterval.start]
    #     self.characterEndOffset = self.sentenceObj.endOffsets[self.tokenInterval.end - 1]
    #     # for later recovery
    #     self.id = None
    #     self.type = self._set_type()

    # def __str__(self):
    #     return &#34;{}: {}&#34;.format(OdinHighlighter.LABEL(self.label), OdinHighlighter.highlight_mention(self))

    # def __eq__(self, other):
    #     if isinstance(other, self.__class__):
    #         return self.__dict__ == other.__dict__
    #     else:
    #         return False

    # def __ne__(self, other):
    #     return not self.__eq__(other)

    # def __hash__(self):
    #     return hash(self.to_JSON())

    # def startOffset(self):
    #     return self.sentenceObj.endOffsets[self.start]

    # def endOffset(self):
    #     return self.sentenceObj.endOffsets[self.end -1]

    # def words(self):
    #     return self.sentenceObj.words[self.start:self.end]

    # def tags(self):
    #     return self.sentenceObj.tags[self.start:self.end]

    # def lemmas(self):
    #     return self.sentenceObj.lemmas[self.start:self.end]

    # def _chunks(self):
    #     return self.sentenceObj._chunks[self.start:self.end]

    # def _entities(self):
    #     return self.sentenceObj._entities[self.start:self.end]

    # def overlaps(self, other):
    #     &#34;&#34;&#34;
    #     Checks for overlap.
    #     &#34;&#34;&#34;
    #     if isinstance(other, int):
    #         return self.start &lt;= other &lt; self.end
    #     elif isinstance(other, Mention):
    #         # equiv. sentences + checks on start and end
    #         return (self.sentence.__hash__() == other.sentence.__hash__()) and \
    #         self.tokenInterval.overlaps(other.tokenInterval)
    #     else:
    #         return False



    # def _arguments_to_JSON_dict(self):
    #     return dict((role, [a.to_JSON_dict() for a in args]) for (role, args) in self.arguments.items())

    # def _paths_to_JSON_dict(self):
    #     return {role: paths.to_JSON_dict() for (role, paths) in self.paths}

    # @staticmethod
    # def load_from_JSON(mjson, docs_dict):
    #     # recover document
    #     doc_id = mjson[&#34;document&#34;]
    #     doc = docs_dict[doc_id]
    #     labels = mjson[&#34;labels&#34;]
    #     kwargs = {
    #         &#34;label&#34;: mjson.get(&#34;label&#34;, labels[0]),
    #         &#34;labels&#34;: labels,
    #         &#34;token_interval&#34;: Interval.load_from_JSON(mjson[&#34;tokenInterval&#34;]),
    #         &#34;sentence&#34;: mjson[&#34;sentence&#34;],
    #         &#34;document&#34;: doc,
    #         &#34;doc_id&#34;: doc_id,
    #         &#34;trigger&#34;: mjson.get(&#34;trigger&#34;, None),
    #         &#34;arguments&#34;: mjson.get(&#34;arguments&#34;, None),
    #         &#34;paths&#34;: mjson.get(&#34;paths&#34;, None),
    #         &#34;keep&#34;: mjson.get(&#34;keep&#34;, True),
    #         &#34;foundBy&#34;: mjson[&#34;foundBy&#34;]
    #     }
    #     m = Mention(**kwargs)
    #     # set IDs
    #     m.id = mjson[&#34;id&#34;]
    #     m._doc_id = doc_id
    #     # set character offsets
    #     m.character_start_offset = mjson[&#34;characterStartOffset&#34;]
    #     m.character_end_offset = mjson[&#34;characterEndOffset&#34;]
    #     return m

    # def _to_document_map(self):
    #     return {self._doc_id: self.document}

    # def _set_type(self):
    #     # event mention
    #     if self.trigger != None:
    #         return Mention.EM
    #     # textbound mention
    #     elif self.trigger == None and self.arguments == None:
    #         return Mention.TBM
    #     else:
    #         return Mention.RM


class TextBoundMention(Mention):

  # override from Mention
  arguments: typing.Optional[Mention.Arguments] = Field(default=None, description=&#34;A TextBoundMention has no arguments&#34;)
  paths: typing.Optional[Mention.Paths] = Field(default=None, description=&#34;A TextBoundMention has no paths&#34;)

class RelationMention(Mention):
  # FIXME: ensure arguments dict is non-empt

  # TODO: implement me
  # see https://github.com/clulab/processors/blob/9f89ea7bf6ac551f77dbfdbb8eec9bf216711df4/main/src/main/scala/org/clulab/odin/Mention.scala
  @property
  def is_valid(self) -&gt; bool:
    &#34;&#34;&#34;returns true if this is a valid mention&#34;&#34;&#34;
    # args should all be from same sentence
    raise NotImplementedError
  
  # TODO: implement me
  @property
  def to_event_mention(trigger: TextBoundMention) -&gt; &#34;EventMention&#34;:
    &#34;&#34;&#34;&#34;&#34;&#34;
    # check that trigger and self have same sent and doc
    raise NotImplementedError

  # TODO: implement me
  def scatter(arg_name: str, size: int) -&gt; list[RelationMention]:
    raise NotImplementedError
  # arguments
  #   .getOrElse(argName, Nil)
  #   .combinations(size)
  #   .map(args =&gt; this + (argName -&gt; args))
  #   .toList

  # TODO: implement me
  # Create a new EventMention by removing a single argument
  def __sub__(other: typing.Any) -&gt; RelationMention:
    raise NotImplementedError
    #copy(arguments = this.arguments - argName)
    # Create a new EventMention by removing a sequence of arguments
    # def --(argNames: Seq[String]): EventMention =
    #   copy(arguments = this.arguments -- argNames)

  # TODO: implement me
  def __add__(other: typing.Any) -&gt; RelationMention:
    &#34;&#34;&#34;Create a new RelationMention by adding a key, value pair to the arguments map&#34;&#34;&#34;
    #def +(arg: (String, Seq[Mention])): RelationMention =
    #copy(arguments = this.arguments + arg)
    raise NotImplementedError
  
class EventMention(Mention):
  trigger: TextBoundMention = Field(description=&#34;&#34;)
  arguments: Mention.Arguments = Field(default={}, description=&#34;A mapping of the EventMention&#39;s arguments (role -&gt; list[Mention])&#34;)
  paths: typing.Optional[Mention.Paths] = Field(default={}, description=&#34;Graph traversal leading to each argument&#34;)


  def copy(
    self,
    maybe_trigger: typing.Optional[TextBoundMention] = None,
    maybe_labels: typing.Optional[list[str]] = None,
    maybe_token_interval: typing.Optional[Interval] = None,
    maybe_sentence_index: typing.Optional[int] = None,
    maybe_document: typing.Optional[Document] = None,
    maybe_keep: typing.Optional[bool] = None,
    maybe_arguments: typing.Optional[Mention.Arguments] = None,
    maybe_paths: typing.Optional[Mention.Paths] = None,
    maybe_found_by: typing.Optional[str] = None,
  ) -&gt; EventMention:
    return EventMention(
      trigger = maybe_trigger or self.trigger,
      labels = maybe_labels or self.labels,
      token_interval = maybe_token_interval or self.token_interval,
      sentence_index = maybe_sentence_index or self.sentence_index,
      document = maybe_document or self.document,
      keep = maybe_keep or self.keep,
      arguments = maybe_arguments or self.arguments,
      paths = maybe_paths or self.paths,
      found_by = maybe_found_by or self.found_by
    )

  # TODO: implement me
  # see https://github.com/clulab/processors/blob/9f89ea7bf6ac551f77dbfdbb8eec9bf216711df4/main/src/main/scala/org/clulab/odin/Mention.scala#L323-L330
  @property
  def is_valid(self) -&gt; bool:
    &#34;&#34;&#34;returns true if this is a valid mention&#34;&#34;&#34;
    raise NotImplementedError
  
  # TODO: implement me
  def to_relation_mention(self) -&gt; RelationMention:
    raise NotImplementedError
  
  # TODO: implement me
  def scatter(arg_name: str, size: int) -&gt; list[EventMention]:
    raise NotImplementedError
  # arguments
  #   .getOrElse(argName, Nil)
  #   .combinations(size)
  #   .map(args =&gt; this + (argName -&gt; args))
  #   .toList

  # TODO: implement me
  # Create a new EventMention by removing a single argument
  def __sub__(other: typing.Any) -&gt; EventMention:
    raise NotImplementedError
    #copy(arguments = this.arguments - argName)
    # Create a new EventMention by removing a sequence of arguments
    # def --(argNames: Seq[String]): EventMention =
    #   copy(arguments = this.arguments -- argNames)

  # TODO: implement me
  def __add__(other: typing.Any) -&gt; EventMention:
    &#34;&#34;&#34;Create a new EventMention by adding a key, value pair to the arguments map&#34;&#34;&#34;
    #def +(arg: (String, Seq[Mention])): EventMention =
    #copy(arguments = this.arguments + arg)
    raise NotImplementedError
  
class CrossSentenceMention(Mention):
  anchor: Mention = Field(description=&#34;The mention serving as the anchor for this cross-sentence mention&#34;)
  neighbor: Mention = Field(description=&#34;The second mention for this cross-sentence mention&#34;)

  # FIXME: add check on arguments  
  #require(arguments.size == 2, &#34;CrossSentenceMention must have exactly two arguments&#34;)
  # assert anchor.document == neighbor.document
  # assert anchor.sentence_obj != neighbor.sentence_obj</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lum.clu.odin.mention.CrossSentenceMention"><code class="flex name class">
<span>class <span class="ident">CrossSentenceMention</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.5/concepts/models/">https://docs.pydantic.dev/2.5/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of classvars defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The signature for instantiating the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a <code>RootModel</code>.</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The pydantic-core SchemaSerializer used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The pydantic-core SchemaValidator used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>An instance attribute with the values of extra fields from validation when
<code>model_config['extra'] == 'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>An instance attribute with the names of fields explicitly set.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Instance attribute with the values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>__init__</code> uses <code>__pydantic_self__</code> instead of the more common <code>self</code> for the first arg to
allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CrossSentenceMention(Mention):
  anchor: Mention = Field(description=&#34;The mention serving as the anchor for this cross-sentence mention&#34;)
  neighbor: Mention = Field(description=&#34;The second mention for this cross-sentence mention&#34;)

  # FIXME: add check on arguments  
  #require(arguments.size == 2, &#34;CrossSentenceMention must have exactly two arguments&#34;)
  # assert anchor.document == neighbor.document
  # assert anchor.sentence_obj != neighbor.sentence_obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lum.clu.odin.mention.CrossSentenceMention.anchor"><code class="name">var <span class="ident">anchor</span> : <a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.CrossSentenceMention.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.CrossSentenceMention.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.CrossSentenceMention.neighbor"><code class="name">var <span class="ident">neighbor</span> : <a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></b></code>:
<ul class="hlist">
<li><code><a title="lum.clu.odin.mention.Mention.char_end_offset" href="#lum.clu.odin.mention.Mention.char_end_offset">char_end_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.char_start_offset" href="#lum.clu.odin.mention.Mention.char_start_offset">char_start_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.chunks" href="#lum.clu.odin.mention.Mention.chunks">chunks</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.copy" href="#lum.clu.odin.mention.Mention.copy">copy</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.end" href="#lum.clu.odin.mention.Mention.end">end</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.endOffset" href="#lum.clu.odin.mention.Mention.endOffset">endOffset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.end_offset" href="#lum.clu.odin.mention.Mention.end_offset">end_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.entities" href="#lum.clu.odin.mention.Mention.entities">entities</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.isValid" href="#lum.clu.odin.mention.Mention.isValid">isValid</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.is_valid" href="#lum.clu.odin.mention.Mention.is_valid">is_valid</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.label" href="#lum.clu.odin.mention.Mention.label">label</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.lemmas" href="#lum.clu.odin.mention.Mention.lemmas">lemmas</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.matches" href="#lum.clu.odin.mention.Mention.matches">matches</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.norms" href="#lum.clu.odin.mention.Mention.norms">norms</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.raw" href="#lum.clu.odin.mention.Mention.raw">raw</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.start" href="#lum.clu.odin.mention.Mention.start">start</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.startOffset" href="#lum.clu.odin.mention.Mention.startOffset">startOffset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.start_offset" href="#lum.clu.odin.mention.Mention.start_offset">start_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.tags" href="#lum.clu.odin.mention.Mention.tags">tags</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.text" href="#lum.clu.odin.mention.Mention.text">text</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.words" href="#lum.clu.odin.mention.Mention.words">words</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lum.clu.odin.mention.EventMention"><code class="flex name class">
<span>class <span class="ident">EventMention</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.5/concepts/models/">https://docs.pydantic.dev/2.5/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of classvars defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The signature for instantiating the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a <code>RootModel</code>.</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The pydantic-core SchemaSerializer used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The pydantic-core SchemaValidator used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>An instance attribute with the values of extra fields from validation when
<code>model_config['extra'] == 'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>An instance attribute with the names of fields explicitly set.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Instance attribute with the values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>__init__</code> uses <code>__pydantic_self__</code> instead of the more common <code>self</code> for the first arg to
allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventMention(Mention):
  trigger: TextBoundMention = Field(description=&#34;&#34;)
  arguments: Mention.Arguments = Field(default={}, description=&#34;A mapping of the EventMention&#39;s arguments (role -&gt; list[Mention])&#34;)
  paths: typing.Optional[Mention.Paths] = Field(default={}, description=&#34;Graph traversal leading to each argument&#34;)


  def copy(
    self,
    maybe_trigger: typing.Optional[TextBoundMention] = None,
    maybe_labels: typing.Optional[list[str]] = None,
    maybe_token_interval: typing.Optional[Interval] = None,
    maybe_sentence_index: typing.Optional[int] = None,
    maybe_document: typing.Optional[Document] = None,
    maybe_keep: typing.Optional[bool] = None,
    maybe_arguments: typing.Optional[Mention.Arguments] = None,
    maybe_paths: typing.Optional[Mention.Paths] = None,
    maybe_found_by: typing.Optional[str] = None,
  ) -&gt; EventMention:
    return EventMention(
      trigger = maybe_trigger or self.trigger,
      labels = maybe_labels or self.labels,
      token_interval = maybe_token_interval or self.token_interval,
      sentence_index = maybe_sentence_index or self.sentence_index,
      document = maybe_document or self.document,
      keep = maybe_keep or self.keep,
      arguments = maybe_arguments or self.arguments,
      paths = maybe_paths or self.paths,
      found_by = maybe_found_by or self.found_by
    )

  # TODO: implement me
  # see https://github.com/clulab/processors/blob/9f89ea7bf6ac551f77dbfdbb8eec9bf216711df4/main/src/main/scala/org/clulab/odin/Mention.scala#L323-L330
  @property
  def is_valid(self) -&gt; bool:
    &#34;&#34;&#34;returns true if this is a valid mention&#34;&#34;&#34;
    raise NotImplementedError
  
  # TODO: implement me
  def to_relation_mention(self) -&gt; RelationMention:
    raise NotImplementedError
  
  # TODO: implement me
  def scatter(arg_name: str, size: int) -&gt; list[EventMention]:
    raise NotImplementedError
  # arguments
  #   .getOrElse(argName, Nil)
  #   .combinations(size)
  #   .map(args =&gt; this + (argName -&gt; args))
  #   .toList

  # TODO: implement me
  # Create a new EventMention by removing a single argument
  def __sub__(other: typing.Any) -&gt; EventMention:
    raise NotImplementedError
    #copy(arguments = this.arguments - argName)
    # Create a new EventMention by removing a sequence of arguments
    # def --(argNames: Seq[String]): EventMention =
    #   copy(arguments = this.arguments -- argNames)

  # TODO: implement me
  def __add__(other: typing.Any) -&gt; EventMention:
    &#34;&#34;&#34;Create a new EventMention by adding a key, value pair to the arguments map&#34;&#34;&#34;
    #def +(arg: (String, Seq[Mention])): EventMention =
    #copy(arguments = this.arguments + arg)
    raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lum.clu.odin.mention.EventMention.arguments"><code class="name">var <span class="ident">arguments</span> : dict[str, list[<a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.EventMention.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.EventMention.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.EventMention.paths"><code class="name">var <span class="ident">paths</span> : Optional[dict[str, dict[<a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a>, <a title="lum.clu.odin.synpath.SynPath" href="synpath.html#lum.clu.odin.synpath.SynPath">SynPath</a>]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.EventMention.trigger"><code class="name">var <span class="ident">trigger</span> : <a title="lum.clu.odin.mention.TextBoundMention" href="#lum.clu.odin.mention.TextBoundMention">TextBoundMention</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lum.clu.odin.mention.EventMention.scatter"><code class="name flex">
<span>def <span class="ident">scatter</span></span>(<span>arg_name: str, size: int) ‑> list[<a title="lum.clu.odin.mention.EventMention" href="#lum.clu.odin.mention.EventMention">EventMention</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatter(arg_name: str, size: int) -&gt; list[EventMention]:
  raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.EventMention.to_relation_mention"><code class="name flex">
<span>def <span class="ident">to_relation_mention</span></span>(<span>self) ‑> <a title="lum.clu.odin.mention.RelationMention" href="#lum.clu.odin.mention.RelationMention">RelationMention</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_relation_mention(self) -&gt; RelationMention:
  raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></b></code>:
<ul class="hlist">
<li><code><a title="lum.clu.odin.mention.Mention.char_end_offset" href="#lum.clu.odin.mention.Mention.char_end_offset">char_end_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.char_start_offset" href="#lum.clu.odin.mention.Mention.char_start_offset">char_start_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.chunks" href="#lum.clu.odin.mention.Mention.chunks">chunks</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.copy" href="#lum.clu.odin.mention.Mention.copy">copy</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.end" href="#lum.clu.odin.mention.Mention.end">end</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.endOffset" href="#lum.clu.odin.mention.Mention.endOffset">endOffset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.end_offset" href="#lum.clu.odin.mention.Mention.end_offset">end_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.entities" href="#lum.clu.odin.mention.Mention.entities">entities</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.isValid" href="#lum.clu.odin.mention.Mention.isValid">isValid</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.is_valid" href="#lum.clu.odin.mention.Mention.is_valid">is_valid</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.label" href="#lum.clu.odin.mention.Mention.label">label</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.lemmas" href="#lum.clu.odin.mention.Mention.lemmas">lemmas</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.matches" href="#lum.clu.odin.mention.Mention.matches">matches</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.norms" href="#lum.clu.odin.mention.Mention.norms">norms</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.raw" href="#lum.clu.odin.mention.Mention.raw">raw</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.start" href="#lum.clu.odin.mention.Mention.start">start</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.startOffset" href="#lum.clu.odin.mention.Mention.startOffset">startOffset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.start_offset" href="#lum.clu.odin.mention.Mention.start_offset">start_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.tags" href="#lum.clu.odin.mention.Mention.tags">tags</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.text" href="#lum.clu.odin.mention.Mention.text">text</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.words" href="#lum.clu.odin.mention.Mention.words">words</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lum.clu.odin.mention.Mention"><code class="flex name class">
<span>class <span class="ident">Mention</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.5/concepts/models/">https://docs.pydantic.dev/2.5/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of classvars defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The signature for instantiating the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a <code>RootModel</code>.</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The pydantic-core SchemaSerializer used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The pydantic-core SchemaValidator used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>An instance attribute with the values of extra fields from validation when
<code>model_config['extra'] == 'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>An instance attribute with the names of fields explicitly set.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Instance attribute with the values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>__init__</code> uses <code>__pydantic_self__</code> instead of the more common <code>self</code> for the first arg to
allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mention(BaseModel):

  Paths: typing.ClassVar[typing.TypeAlias] = dict[str, dict[&#34;Mention&#34;, SynPath]]

  Arguments: typing.ClassVar[typing.TypeAlias] = dict[str, list[&#34;Mention&#34;]]
  # FIXME: add validation that this is non-empty?
  labels: list[str] = Field(description=&#34;A sequence of labels for this mention. The first label in the sequence is considered the default.&#34;)
  # alias=&#34;tokenInterval&#34;, 
  token_interval: Interval  = Field(description=&#34;The interval of token indicess that form this mention.&#34;)
  # alias=&#34;sentence&#34;, 
  sentence_index: int = Field(description=&#34;The index of the sentence where this mention occurs.&#34;)

  document: Document = Field(description=&#34;The document where this mention occurs&#34;)

  keep: bool = Field(default=True, description=&#34;Should we report this mention at the end?&#34;)

  arguments: typing.Optional[Mention.Arguments] = Field(default=None, description=&#34;A map from argument name to a sequence of mentions. The value of the map is a sequence because there are events that can have several arguments with the same name. For example, in the biodomain, Binding may have several themes.&#34;)

  paths: typing.Optional[Paths] = Field(default=None, description=&#34;Graph traversal leading to each argument&#34;)
  # alias=&#34;foundBy&#34;
  found_by: str = Field(default=&#34;unknown&#34;, description=&#34;The name of the rule that produced this mention&#34;)

  def copy(
    self,
    maybe_labels: typing.Optional[list[str]] = None,
    maybe_token_interval: typing.Optional[Interval] = None,
    maybe_sentence_index: typing.Optional[int] = None,
    maybe_document: typing.Optional[Document] = None,
    maybe_keep: typing.Optional[bool] = None,
    maybe_arguments: typing.Optional[Mention.Arguments] = None,
    maybe_paths: typing.Optional[Mention.Paths] = None,
    maybe_found_by: typing.Optional[str] = None,
  ) -&gt; Mention:
    return Mention(
      labels = maybe_labels or self.labels,
      token_interval = maybe_token_interval or self.token_interval,
      sentence_index = maybe_sentence_index or self.sentence_index,
      document = maybe_document or self.document,
      keep = maybe_keep or self.keep,
      arguments = maybe_arguments or self.arguments,
      paths = maybe_paths or self.paths,
      found_by = maybe_found_by or self.found_by
    )

  @property
  def label(self) -&gt; str:
    &#34;&#34;&#34;the first label for the mention&#34;&#34;&#34;
    return self.labels[0]
    
  @property
  def start(self) -&gt; int:
    &#34;&#34;&#34;index of the first token in the mention&#34;&#34;&#34;
    return self.token_interval.start

  @property
  def end(self) -&gt; int:
    &#34;&#34;&#34;one after the last token in the mention&#34;&#34;&#34;
    return self.token_interval.end
  
  @property
  def sentence_obj(self) -&gt; Sentence:
    return self.document.sentences[self.sentence_index]

  @property
  def sentenceObj(self) -&gt; Sentence:
    self.sentence_obj

  @property
  def start_offset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention beginning&#34;&#34;&#34;
    return self.sentence_obj.start_offsets[self.start]

  @property
  def startOffset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention beginning&#34;&#34;&#34;
    return self.start_offset 

  @property
  def char_start_offset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention beginning&#34;&#34;&#34;
    return self.start_offset 
  
  @property
  def end_offset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention end&#34;&#34;&#34;
    return self.sentence_obj.end_offsets[self.end - 1]

  @property
  def endOffset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention end&#34;&#34;&#34;
    return self.end_offset 

  @property
  def char_end_offset(self) -&gt; int:
    &#34;&#34;&#34;character offset of the mention end&#34;&#34;&#34;
    return self.end_offset 
  
  @property
  def is_valid(self) -&gt; bool:
    &#34;&#34;&#34;returns true if this is a valid mention&#34;&#34;&#34;
    return True

  @property
  def isValid(self) -&gt; bool:
    &#34;&#34;&#34;returns true if this is a valid mention&#34;&#34;&#34;
    return self.is_valid

  def matches(self, label_or_pattern: typing.Union[str, re.Pattern]) -&gt; bool:
    &#34;&#34;&#34;returns true if `label_or_pattern` matches any of the mention labels&#34;&#34;&#34;
    if isinstance(label_or_pattern, str):
      return label_or_pattern in self.labels
    elif isinstance(label_or_pattern, re.Pattern):
      patt = label_or_pattern
      return True if any(re.match(patt, lbl) != None for lbl in self.labels) else False
    return False

  @property
  def raw(self) -&gt; list[str]:
    &#34;&#34;&#34;returns all raw (original, no processing applied) tokens in mention&#34;&#34;&#34;
    return self.sentence_obj.raw[self.start:self.end]

  @property
  def words(self) -&gt; list[str]:
    &#34;&#34;&#34;returns all tokens in mention&#34;&#34;&#34;
    return self.sentence_obj.words[self.start:self.end]

  @property
  def tags(self) -&gt; typing.Optional[list[str]]:
    &#34;&#34;&#34;returns all tags in mention&#34;&#34;&#34;
    if self.sentence_obj.tags:
      return self.sentence_obj.tags[self.start:self.end]
    return None
  
  @property
  def lemmas(self) -&gt; typing.Optional[list[str]]:
    &#34;&#34;&#34;returns all lemmas in mention&#34;&#34;&#34;
    if self.sentence_obj.lemmas:
      return self.sentence_obj.lemmas[self.start:self.end]
    return None
  
  @property
  def entities(self) -&gt; typing.Optional[list[str]]:
    &#34;&#34;&#34;returns all entities in mention&#34;&#34;&#34;
    if self.sentence_obj.entities:
      return self.sentence_obj.entities[self.start:self.end]
    return None
  
  @property
  def norms(self) -&gt; typing.Optional[list[str]]:
    &#34;&#34;&#34;returns all norms in mention&#34;&#34;&#34;
    if self.sentence_obj.norms:
      return self.sentence_obj.norms[self.start:self.end]
    return None
  
  @property
  def chunks(self) -&gt; typing.Optional[list[str]]:
    &#34;&#34;&#34;returns all chunks in mention&#34;&#34;&#34;
    if self.sentence_obj.chunks:
      return self.sentence_obj.chunks[self.start:self.end]
    return None

  @property
  def text(self) -&gt; str:
    &#34;&#34;&#34;returns a string that contains the mention&#34;&#34;&#34;
    _text = self.document.text
    if _text is not None:
      return _text[self.start_offset:self.end_offset]
    # FIXME: this can be improved
    else:
      return &#34; &#34;.join(self.raw[self.start:self.end])

  # /** returns a string that contains the mention */
  # def text: String = document.text match {
  #   case Some(txt) =&gt; txt.slice(startOffset, endOffset)
  #   case None =&gt;
  #     // try to reconstruct the sentence using the character offsets
  #     val bits = raw.head +: tokenInterval.tail.map { i =&gt;
  #       val spaces = &#34; &#34; * (sentenceObj.startOffsets(i) - sentenceObj.endOffsets(i - 1))
  #       val rawWord = sentenceObj.raw(i)
  #       spaces + rawWord
  #     }
  #     bits.mkString
  # }
    
  # /** returns all syntactic heads */
  # def synHeads: Seq[Int] = sentenceObj.dependencies match {
  #   case Some(deps) =&gt; DependencyUtils.findHeads(tokenInterval, deps)
  #   case None =&gt; Nil
  # }

  # /** returns the minimum distance to a root node for dependencies within the token interval */
  # def distToRootOpt: Option[Int] = sentenceObj.dependencies.flatMap { deps =&gt;
  #   // Note that
  #   // Double.MaxValue.toInt == Int.MaxValue
  #   // Double.PositiveInfinity.toInt == Int.MaxValue
  #   DependencyUtils.distToRootOpt(tokenInterval, deps).map(_.toInt)
  # }

  # /** returns the syntactic head of `mention`  */
  # def synHead: Option[Int] = synHeads.lastOption

  # /** returns head token */
  # def synHeadWord: Option[String] = synHead.map(i =&gt; sentenceObj.words(i))

  # /** returns head pos tag */
  # def synHeadTag: Option[String] = synHead.flatMap(i =&gt; sentenceObj.tags.map(_(i)))

  # /** returns head lemma */
  # def synHeadLemma: Option[String] = synHead.flatMap(i =&gt; sentenceObj.lemmas.map(_(i)))

  # /** returns all semantic heads */
  # def semHeads: Seq[Int] = DependencyUtils.findHeadsStrict(tokenInterval, sentenceObj)

  # /** returns the syntactic head of `mention`  */
  # def semHead: Option[Int] = semHeads.lastOption

  # /** returns head token */
  # def semHeadWord: Option[String] = semHead.map(i =&gt; sentenceObj.words(i))

  # /** returns head pos tag */
  # def semHeadTag: Option[String] = semHead.flatMap(i =&gt; sentenceObj.tags.map(_(i)))

  # /** returns head lemma */
  # def semHeadLemma: Option[String] = semHead.flatMap(i =&gt; sentenceObj.lemmas.map(_(i)))


  # override def canEqual(a: Any) = a.isInstanceOf[Mention]

  # override def equals(that: Any): Boolean = that match {
  #   case that: Mention =&gt; that.canEqual(this) &amp;&amp; this.hashCode == that.hashCode
  #   case _ =&gt; false
  # }

  # def compare(that: Mention): Int = {
  #   require(this.document == that.document,
  #     &#34;can&#39;t compare mentions if they belong to different documents&#34;)
  #   if (this.sentence &lt; that.sentence) -1
  #   else if (this.sentence &gt; that.sentence) 1
  #   else this.tokenInterval compare that.tokenInterval
  # }

  # def precedes(that: Mention): Boolean = this.compare(that) &lt; 0

# class Mention(BaseModel):
    
#     TBM: typing.ClassVar[str] = &#34;TextBoundMention&#34;
#     EM: typing.ClassVar[str] = &#34;EventMention&#34;
#     RM: typing.ClassVar[str] = &#34;RelationMention&#34;

#     &#34;&#34;&#34;
#     A labeled span of text.  Used to model textual mentions of events, relations, and entities.

#     Parameters
#     ----------
#     token_interval : Interval
#         The span of the Mention represented as an Interval.
#     sentence : int
#         The sentence index that contains the Mention.
#     document : Document
#         The Document in which the Mention was found.
#     foundBy : str
#         The Odin IE rule that produced this Mention.
#     label : str
#         The label most closely associated with this span.  Usually the lowest hyponym of &#34;labels&#34;.
#     labels: list
#         The list of labels associated with this span.
#     trigger: dict or None
#         dict of JSON for Mention&#39;s trigger (event predicate or word(s) signaling the Mention).
#     arguments: dict or None
#         dict of JSON for Mention&#39;s arguments.
#     paths: dict or None
#         dict of JSON encoding the syntactic paths linking a Mention&#39;s arguments to its trigger (applies to Mentions produces from `type:&#34;dependency&#34;` rules).
#     doc_id: str or None
#         the id of the document

#     Attributes
#     ----------
#     tokenInterval: processors.ds.Interval
#         An `Interval` encoding the `start` and `end` of the `Mention`.
#     start : int
#         The token index that starts the `Mention`.
#     end : int
#         The token index that marks the end of the Mention (exclusive).
#     sentenceObj : processors.ds.Sentence
#         Pointer to the `Sentence` instance containing the `Mention`.
#     characterStartOffset: int
#         The index of the character that starts the `Mention`.
#     characterEndOffset: int
#         The index of the character that ends the `Mention`.
#     type: Mention.TBM or Mention.EM or Mention.RM
#         The type of the `Mention`.

#     See Also
#     --------

#     [`Odin` manual](https://arxiv.org/abs/1509.07513)

#     Methods
#     -------
#     matches(label_pattern)
#         Test if the provided pattern, `label_pattern`, matches any element in `Mention.labels`.

#     overlaps(other)
#         Test whether other (token index or Mention) overlaps with span of this Mention.

#     copy(**kwargs)
#         Copy constructor for this Mention.

#     words()
#         Words for this Mention&#39;s span.

#     tags()
#         Part of speech for this Mention&#39;s span.

#     lemmas()
#         Lemmas for this Mention&#39;s span.

#     _chunks()
#         chunk labels for this Mention&#39;s span.

#     _entities()
#         NE labels for this Mention&#39;s span.
#     &#34;&#34;&#34;

    # def __init__(self,
    #             token_interval,
    #             sentence,
    #             document,
    #             foundBy,
    #             label,
    #             labels=None,
    #             trigger=None,
    #             arguments=None,
    #             paths=None,
    #             keep=True,
    #             doc_id=None):

    #     NLPDatum.__init__(self)
    #     self.label = label
    #     self.labels = labels if labels else [self.label]
    #     self.tokenInterval = token_interval
    #     self.start = self.tokenInterval.start
    #     self.end = self.tokenInterval.end
    #     self.document = document
    #     self._doc_id = doc_id or hash(self.document)
    #     self.sentence = sentence
    #     if trigger:
    #         # NOTE: doc id is not stored for trigger&#39;s json,
    #         # as it is assumed to be contained in the same document as its parent
    #         trigger.update({&#34;document&#34;: self._doc_id})
    #         self.trigger = Mention.load_from_JSON(trigger, self._to_document_map())
    #     else:
    #         self.trigger = None
    #     # unpack args
    #     self.arguments = {role:[Mention.load_from_JSON(a, self._to_document_map()) for a in args] for (role, args) in arguments.items()} if arguments else None
    #     self.paths = paths
    #     self.keep = keep
    #     self.foundBy = foundBy
    #     # other
    #     self.sentenceObj = self.document.sentences[self.sentence]
    #     self.text = &#34; &#34;.join(self.sentenceObj.words[self.start:self.end])
    #     # recover offsets
    #     self.characterStartOffset = self.sentenceObj.startOffsets[self.tokenInterval.start]
    #     self.characterEndOffset = self.sentenceObj.endOffsets[self.tokenInterval.end - 1]
    #     # for later recovery
    #     self.id = None
    #     self.type = self._set_type()

    # def __str__(self):
    #     return &#34;{}: {}&#34;.format(OdinHighlighter.LABEL(self.label), OdinHighlighter.highlight_mention(self))

    # def __eq__(self, other):
    #     if isinstance(other, self.__class__):
    #         return self.__dict__ == other.__dict__
    #     else:
    #         return False

    # def __ne__(self, other):
    #     return not self.__eq__(other)

    # def __hash__(self):
    #     return hash(self.to_JSON())

    # def startOffset(self):
    #     return self.sentenceObj.endOffsets[self.start]

    # def endOffset(self):
    #     return self.sentenceObj.endOffsets[self.end -1]

    # def words(self):
    #     return self.sentenceObj.words[self.start:self.end]

    # def tags(self):
    #     return self.sentenceObj.tags[self.start:self.end]

    # def lemmas(self):
    #     return self.sentenceObj.lemmas[self.start:self.end]

    # def _chunks(self):
    #     return self.sentenceObj._chunks[self.start:self.end]

    # def _entities(self):
    #     return self.sentenceObj._entities[self.start:self.end]

    # def overlaps(self, other):
    #     &#34;&#34;&#34;
    #     Checks for overlap.
    #     &#34;&#34;&#34;
    #     if isinstance(other, int):
    #         return self.start &lt;= other &lt; self.end
    #     elif isinstance(other, Mention):
    #         # equiv. sentences + checks on start and end
    #         return (self.sentence.__hash__() == other.sentence.__hash__()) and \
    #         self.tokenInterval.overlaps(other.tokenInterval)
    #     else:
    #         return False



    # def _arguments_to_JSON_dict(self):
    #     return dict((role, [a.to_JSON_dict() for a in args]) for (role, args) in self.arguments.items())

    # def _paths_to_JSON_dict(self):
    #     return {role: paths.to_JSON_dict() for (role, paths) in self.paths}

    # @staticmethod
    # def load_from_JSON(mjson, docs_dict):
    #     # recover document
    #     doc_id = mjson[&#34;document&#34;]
    #     doc = docs_dict[doc_id]
    #     labels = mjson[&#34;labels&#34;]
    #     kwargs = {
    #         &#34;label&#34;: mjson.get(&#34;label&#34;, labels[0]),
    #         &#34;labels&#34;: labels,
    #         &#34;token_interval&#34;: Interval.load_from_JSON(mjson[&#34;tokenInterval&#34;]),
    #         &#34;sentence&#34;: mjson[&#34;sentence&#34;],
    #         &#34;document&#34;: doc,
    #         &#34;doc_id&#34;: doc_id,
    #         &#34;trigger&#34;: mjson.get(&#34;trigger&#34;, None),
    #         &#34;arguments&#34;: mjson.get(&#34;arguments&#34;, None),
    #         &#34;paths&#34;: mjson.get(&#34;paths&#34;, None),
    #         &#34;keep&#34;: mjson.get(&#34;keep&#34;, True),
    #         &#34;foundBy&#34;: mjson[&#34;foundBy&#34;]
    #     }
    #     m = Mention(**kwargs)
    #     # set IDs
    #     m.id = mjson[&#34;id&#34;]
    #     m._doc_id = doc_id
    #     # set character offsets
    #     m.character_start_offset = mjson[&#34;characterStartOffset&#34;]
    #     m.character_end_offset = mjson[&#34;characterEndOffset&#34;]
    #     return m

    # def _to_document_map(self):
    #     return {self._doc_id: self.document}

    # def _set_type(self):
    #     # event mention
    #     if self.trigger != None:
    #         return Mention.EM
    #     # textbound mention
    #     elif self.trigger == None and self.arguments == None:
    #         return Mention.TBM
    #     else:
    #         return Mention.RM</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="lum.clu.odin.mention.CrossSentenceMention" href="#lum.clu.odin.mention.CrossSentenceMention">CrossSentenceMention</a></li>
<li><a title="lum.clu.odin.mention.EventMention" href="#lum.clu.odin.mention.EventMention">EventMention</a></li>
<li><a title="lum.clu.odin.mention.RelationMention" href="#lum.clu.odin.mention.RelationMention">RelationMention</a></li>
<li><a title="lum.clu.odin.mention.TextBoundMention" href="#lum.clu.odin.mention.TextBoundMention">TextBoundMention</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lum.clu.odin.mention.Mention.Arguments"><code class="name">var <span class="ident">Arguments</span> : ClassVar[TypeAlias]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.Mention.Paths"><code class="name">var <span class="ident">Paths</span> : ClassVar[TypeAlias]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.Mention.arguments"><code class="name">var <span class="ident">arguments</span> : Optional[dict[str, list[<a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a>]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.Mention.document"><code class="name">var <span class="ident">document</span> : <a title="lum.clu.processors.document.Document" href="../processors/document.html#lum.clu.processors.document.Document">Document</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.Mention.found_by"><code class="name">var <span class="ident">found_by</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.Mention.keep"><code class="name">var <span class="ident">keep</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.Mention.labels"><code class="name">var <span class="ident">labels</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.Mention.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.Mention.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.Mention.paths"><code class="name">var <span class="ident">paths</span> : Optional[dict[str, dict[<a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a>, <a title="lum.clu.odin.synpath.SynPath" href="synpath.html#lum.clu.odin.synpath.SynPath">SynPath</a>]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.Mention.sentence_index"><code class="name">var <span class="ident">sentence_index</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.Mention.token_interval"><code class="name">var <span class="ident">token_interval</span> : <a title="lum.clu.processors.interval.Interval" href="../processors/interval.html#lum.clu.processors.interval.Interval">Interval</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="lum.clu.odin.mention.Mention.char_end_offset"><code class="name">var <span class="ident">char_end_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>character offset of the mention end</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def char_end_offset(self) -&gt; int:
  &#34;&#34;&#34;character offset of the mention end&#34;&#34;&#34;
  return self.end_offset </code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.char_start_offset"><code class="name">var <span class="ident">char_start_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>character offset of the mention beginning</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def char_start_offset(self) -&gt; int:
  &#34;&#34;&#34;character offset of the mention beginning&#34;&#34;&#34;
  return self.start_offset </code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.chunks"><code class="name">var <span class="ident">chunks</span> : Optional[list[str]]</code></dt>
<dd>
<div class="desc"><p>returns all chunks in mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def chunks(self) -&gt; typing.Optional[list[str]]:
  &#34;&#34;&#34;returns all chunks in mention&#34;&#34;&#34;
  if self.sentence_obj.chunks:
    return self.sentence_obj.chunks[self.start:self.end]
  return None</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.end"><code class="name">var <span class="ident">end</span> : int</code></dt>
<dd>
<div class="desc"><p>one after the last token in the mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end(self) -&gt; int:
  &#34;&#34;&#34;one after the last token in the mention&#34;&#34;&#34;
  return self.token_interval.end</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.endOffset"><code class="name">var <span class="ident">endOffset</span> : int</code></dt>
<dd>
<div class="desc"><p>character offset of the mention end</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def endOffset(self) -&gt; int:
  &#34;&#34;&#34;character offset of the mention end&#34;&#34;&#34;
  return self.end_offset </code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.end_offset"><code class="name">var <span class="ident">end_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>character offset of the mention end</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_offset(self) -&gt; int:
  &#34;&#34;&#34;character offset of the mention end&#34;&#34;&#34;
  return self.sentence_obj.end_offsets[self.end - 1]</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.entities"><code class="name">var <span class="ident">entities</span> : Optional[list[str]]</code></dt>
<dd>
<div class="desc"><p>returns all entities in mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def entities(self) -&gt; typing.Optional[list[str]]:
  &#34;&#34;&#34;returns all entities in mention&#34;&#34;&#34;
  if self.sentence_obj.entities:
    return self.sentence_obj.entities[self.start:self.end]
  return None</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.isValid"><code class="name">var <span class="ident">isValid</span> : bool</code></dt>
<dd>
<div class="desc"><p>returns true if this is a valid mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isValid(self) -&gt; bool:
  &#34;&#34;&#34;returns true if this is a valid mention&#34;&#34;&#34;
  return self.is_valid</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.is_valid"><code class="name">var <span class="ident">is_valid</span> : bool</code></dt>
<dd>
<div class="desc"><p>returns true if this is a valid mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_valid(self) -&gt; bool:
  &#34;&#34;&#34;returns true if this is a valid mention&#34;&#34;&#34;
  return True</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.label"><code class="name">var <span class="ident">label</span> : str</code></dt>
<dd>
<div class="desc"><p>the first label for the mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def label(self) -&gt; str:
  &#34;&#34;&#34;the first label for the mention&#34;&#34;&#34;
  return self.labels[0]</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.lemmas"><code class="name">var <span class="ident">lemmas</span> : Optional[list[str]]</code></dt>
<dd>
<div class="desc"><p>returns all lemmas in mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lemmas(self) -&gt; typing.Optional[list[str]]:
  &#34;&#34;&#34;returns all lemmas in mention&#34;&#34;&#34;
  if self.sentence_obj.lemmas:
    return self.sentence_obj.lemmas[self.start:self.end]
  return None</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.norms"><code class="name">var <span class="ident">norms</span> : Optional[list[str]]</code></dt>
<dd>
<div class="desc"><p>returns all norms in mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def norms(self) -&gt; typing.Optional[list[str]]:
  &#34;&#34;&#34;returns all norms in mention&#34;&#34;&#34;
  if self.sentence_obj.norms:
    return self.sentence_obj.norms[self.start:self.end]
  return None</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.raw"><code class="name">var <span class="ident">raw</span> : list[str]</code></dt>
<dd>
<div class="desc"><p>returns all raw (original, no processing applied) tokens in mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw(self) -&gt; list[str]:
  &#34;&#34;&#34;returns all raw (original, no processing applied) tokens in mention&#34;&#34;&#34;
  return self.sentence_obj.raw[self.start:self.end]</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.sentenceObj"><code class="name">var <span class="ident">sentenceObj</span> : <a title="lum.clu.processors.sentence.Sentence" href="../processors/sentence.html#lum.clu.processors.sentence.Sentence">Sentence</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sentenceObj(self) -&gt; Sentence:
  self.sentence_obj</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.sentence_obj"><code class="name">var <span class="ident">sentence_obj</span> : <a title="lum.clu.processors.sentence.Sentence" href="../processors/sentence.html#lum.clu.processors.sentence.Sentence">Sentence</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sentence_obj(self) -&gt; Sentence:
  return self.document.sentences[self.sentence_index]</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.start"><code class="name">var <span class="ident">start</span> : int</code></dt>
<dd>
<div class="desc"><p>index of the first token in the mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start(self) -&gt; int:
  &#34;&#34;&#34;index of the first token in the mention&#34;&#34;&#34;
  return self.token_interval.start</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.startOffset"><code class="name">var <span class="ident">startOffset</span> : int</code></dt>
<dd>
<div class="desc"><p>character offset of the mention beginning</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def startOffset(self) -&gt; int:
  &#34;&#34;&#34;character offset of the mention beginning&#34;&#34;&#34;
  return self.start_offset </code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.start_offset"><code class="name">var <span class="ident">start_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>character offset of the mention beginning</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start_offset(self) -&gt; int:
  &#34;&#34;&#34;character offset of the mention beginning&#34;&#34;&#34;
  return self.sentence_obj.start_offsets[self.start]</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.tags"><code class="name">var <span class="ident">tags</span> : Optional[list[str]]</code></dt>
<dd>
<div class="desc"><p>returns all tags in mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tags(self) -&gt; typing.Optional[list[str]]:
  &#34;&#34;&#34;returns all tags in mention&#34;&#34;&#34;
  if self.sentence_obj.tags:
    return self.sentence_obj.tags[self.start:self.end]
  return None</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.text"><code class="name">var <span class="ident">text</span> : str</code></dt>
<dd>
<div class="desc"><p>returns a string that contains the mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">  @property
  def text(self) -&gt; str:
    &#34;&#34;&#34;returns a string that contains the mention&#34;&#34;&#34;
    _text = self.document.text
    if _text is not None:
      return _text[self.start_offset:self.end_offset]
    # FIXME: this can be improved
    else:
      return &#34; &#34;.join(self.raw[self.start:self.end])

  # /** returns a string that contains the mention */
  # def text: String = document.text match {
  #   case Some(txt) =&gt; txt.slice(startOffset, endOffset)
  #   case None =&gt;
  #     // try to reconstruct the sentence using the character offsets
  #     val bits = raw.head +: tokenInterval.tail.map { i =&gt;
  #       val spaces = &#34; &#34; * (sentenceObj.startOffsets(i) - sentenceObj.endOffsets(i - 1))
  #       val rawWord = sentenceObj.raw(i)
  #       spaces + rawWord
  #     }
  #     bits.mkString
  # }
    
  # /** returns all syntactic heads */
  # def synHeads: Seq[Int] = sentenceObj.dependencies match {
  #   case Some(deps) =&gt; DependencyUtils.findHeads(tokenInterval, deps)
  #   case None =&gt; Nil
  # }

  # /** returns the minimum distance to a root node for dependencies within the token interval */
  # def distToRootOpt: Option[Int] = sentenceObj.dependencies.flatMap { deps =&gt;
  #   // Note that
  #   // Double.MaxValue.toInt == Int.MaxValue
  #   // Double.PositiveInfinity.toInt == Int.MaxValue
  #   DependencyUtils.distToRootOpt(tokenInterval, deps).map(_.toInt)
  # }

  # /** returns the syntactic head of `mention`  */
  # def synHead: Option[Int] = synHeads.lastOption

  # /** returns head token */
  # def synHeadWord: Option[String] = synHead.map(i =&gt; sentenceObj.words(i))

  # /** returns head pos tag */
  # def synHeadTag: Option[String] = synHead.flatMap(i =&gt; sentenceObj.tags.map(_(i)))

  # /** returns head lemma */
  # def synHeadLemma: Option[String] = synHead.flatMap(i =&gt; sentenceObj.lemmas.map(_(i)))

  # /** returns all semantic heads */
  # def semHeads: Seq[Int] = DependencyUtils.findHeadsStrict(tokenInterval, sentenceObj)

  # /** returns the syntactic head of `mention`  */
  # def semHead: Option[Int] = semHeads.lastOption

  # /** returns head token */
  # def semHeadWord: Option[String] = semHead.map(i =&gt; sentenceObj.words(i))

  # /** returns head pos tag */
  # def semHeadTag: Option[String] = semHead.flatMap(i =&gt; sentenceObj.tags.map(_(i)))

  # /** returns head lemma */
  # def semHeadLemma: Option[String] = semHead.flatMap(i =&gt; sentenceObj.lemmas.map(_(i)))


  # override def canEqual(a: Any) = a.isInstanceOf[Mention]

  # override def equals(that: Any): Boolean = that match {
  #   case that: Mention =&gt; that.canEqual(this) &amp;&amp; this.hashCode == that.hashCode
  #   case _ =&gt; false
  # }

  # def compare(that: Mention): Int = {
  #   require(this.document == that.document,
  #     &#34;can&#39;t compare mentions if they belong to different documents&#34;)
  #   if (this.sentence &lt; that.sentence) -1
  #   else if (this.sentence &gt; that.sentence) 1
  #   else this.tokenInterval compare that.tokenInterval
  # }

  # def precedes(that: Mention): Boolean = this.compare(that) &lt; 0

# class Mention(BaseModel):
    
#     TBM: typing.ClassVar[str] = &#34;TextBoundMention&#34;
#     EM: typing.ClassVar[str] = &#34;EventMention&#34;
#     RM: typing.ClassVar[str] = &#34;RelationMention&#34;

#     &#34;&#34;&#34;
#     A labeled span of text.  Used to model textual mentions of events, relations, and entities.

#     Parameters
#     ----------
#     token_interval : Interval
#         The span of the Mention represented as an Interval.
#     sentence : int
#         The sentence index that contains the Mention.
#     document : Document
#         The Document in which the Mention was found.
#     foundBy : str
#         The Odin IE rule that produced this Mention.
#     label : str
#         The label most closely associated with this span.  Usually the lowest hyponym of &#34;labels&#34;.
#     labels: list
#         The list of labels associated with this span.
#     trigger: dict or None
#         dict of JSON for Mention&#39;s trigger (event predicate or word(s) signaling the Mention).
#     arguments: dict or None
#         dict of JSON for Mention&#39;s arguments.
#     paths: dict or None
#         dict of JSON encoding the syntactic paths linking a Mention&#39;s arguments to its trigger (applies to Mentions produces from `type:&#34;dependency&#34;` rules).
#     doc_id: str or None
#         the id of the document

#     Attributes
#     ----------
#     tokenInterval: processors.ds.Interval
#         An `Interval` encoding the `start` and `end` of the `Mention`.
#     start : int
#         The token index that starts the `Mention`.
#     end : int
#         The token index that marks the end of the Mention (exclusive).
#     sentenceObj : processors.ds.Sentence
#         Pointer to the `Sentence` instance containing the `Mention`.
#     characterStartOffset: int
#         The index of the character that starts the `Mention`.
#     characterEndOffset: int
#         The index of the character that ends the `Mention`.
#     type: Mention.TBM or Mention.EM or Mention.RM
#         The type of the `Mention`.

#     See Also
#     --------

#     [`Odin` manual](https://arxiv.org/abs/1509.07513)

#     Methods
#     -------
#     matches(label_pattern)
#         Test if the provided pattern, `label_pattern`, matches any element in `Mention.labels`.

#     overlaps(other)
#         Test whether other (token index or Mention) overlaps with span of this Mention.

#     copy(**kwargs)
#         Copy constructor for this Mention.

#     words()
#         Words for this Mention&#39;s span.

#     tags()
#         Part of speech for this Mention&#39;s span.

#     lemmas()
#         Lemmas for this Mention&#39;s span.

#     _chunks()
#         chunk labels for this Mention&#39;s span.

#     _entities()
#         NE labels for this Mention&#39;s span.
#     &#34;&#34;&#34;

    # def __init__(self,
    #             token_interval,
    #             sentence,
    #             document,
    #             foundBy,
    #             label,
    #             labels=None,
    #             trigger=None,
    #             arguments=None,
    #             paths=None,
    #             keep=True,
    #             doc_id=None):

    #     NLPDatum.__init__(self)
    #     self.label = label
    #     self.labels = labels if labels else [self.label]
    #     self.tokenInterval = token_interval
    #     self.start = self.tokenInterval.start
    #     self.end = self.tokenInterval.end
    #     self.document = document
    #     self._doc_id = doc_id or hash(self.document)
    #     self.sentence = sentence
    #     if trigger:
    #         # NOTE: doc id is not stored for trigger&#39;s json,
    #         # as it is assumed to be contained in the same document as its parent
    #         trigger.update({&#34;document&#34;: self._doc_id})
    #         self.trigger = Mention.load_from_JSON(trigger, self._to_document_map())
    #     else:
    #         self.trigger = None
    #     # unpack args
    #     self.arguments = {role:[Mention.load_from_JSON(a, self._to_document_map()) for a in args] for (role, args) in arguments.items()} if arguments else None
    #     self.paths = paths
    #     self.keep = keep
    #     self.foundBy = foundBy
    #     # other
    #     self.sentenceObj = self.document.sentences[self.sentence]
    #     self.text = &#34; &#34;.join(self.sentenceObj.words[self.start:self.end])
    #     # recover offsets
    #     self.characterStartOffset = self.sentenceObj.startOffsets[self.tokenInterval.start]
    #     self.characterEndOffset = self.sentenceObj.endOffsets[self.tokenInterval.end - 1]
    #     # for later recovery
    #     self.id = None
    #     self.type = self._set_type()

    # def __str__(self):
    #     return &#34;{}: {}&#34;.format(OdinHighlighter.LABEL(self.label), OdinHighlighter.highlight_mention(self))

    # def __eq__(self, other):
    #     if isinstance(other, self.__class__):
    #         return self.__dict__ == other.__dict__
    #     else:
    #         return False

    # def __ne__(self, other):
    #     return not self.__eq__(other)

    # def __hash__(self):
    #     return hash(self.to_JSON())

    # def startOffset(self):
    #     return self.sentenceObj.endOffsets[self.start]

    # def endOffset(self):
    #     return self.sentenceObj.endOffsets[self.end -1]

    # def words(self):
    #     return self.sentenceObj.words[self.start:self.end]

    # def tags(self):
    #     return self.sentenceObj.tags[self.start:self.end]

    # def lemmas(self):
    #     return self.sentenceObj.lemmas[self.start:self.end]

    # def _chunks(self):
    #     return self.sentenceObj._chunks[self.start:self.end]

    # def _entities(self):
    #     return self.sentenceObj._entities[self.start:self.end]

    # def overlaps(self, other):
    #     &#34;&#34;&#34;
    #     Checks for overlap.
    #     &#34;&#34;&#34;
    #     if isinstance(other, int):
    #         return self.start &lt;= other &lt; self.end
    #     elif isinstance(other, Mention):
    #         # equiv. sentences + checks on start and end
    #         return (self.sentence.__hash__() == other.sentence.__hash__()) and \
    #         self.tokenInterval.overlaps(other.tokenInterval)
    #     else:
    #         return False



    # def _arguments_to_JSON_dict(self):
    #     return dict((role, [a.to_JSON_dict() for a in args]) for (role, args) in self.arguments.items())

    # def _paths_to_JSON_dict(self):
    #     return {role: paths.to_JSON_dict() for (role, paths) in self.paths}

    # @staticmethod
    # def load_from_JSON(mjson, docs_dict):
    #     # recover document
    #     doc_id = mjson[&#34;document&#34;]
    #     doc = docs_dict[doc_id]
    #     labels = mjson[&#34;labels&#34;]
    #     kwargs = {
    #         &#34;label&#34;: mjson.get(&#34;label&#34;, labels[0]),
    #         &#34;labels&#34;: labels,
    #         &#34;token_interval&#34;: Interval.load_from_JSON(mjson[&#34;tokenInterval&#34;]),
    #         &#34;sentence&#34;: mjson[&#34;sentence&#34;],
    #         &#34;document&#34;: doc,
    #         &#34;doc_id&#34;: doc_id,
    #         &#34;trigger&#34;: mjson.get(&#34;trigger&#34;, None),
    #         &#34;arguments&#34;: mjson.get(&#34;arguments&#34;, None),
    #         &#34;paths&#34;: mjson.get(&#34;paths&#34;, None),
    #         &#34;keep&#34;: mjson.get(&#34;keep&#34;, True),
    #         &#34;foundBy&#34;: mjson[&#34;foundBy&#34;]
    #     }
    #     m = Mention(**kwargs)
    #     # set IDs
    #     m.id = mjson[&#34;id&#34;]
    #     m._doc_id = doc_id
    #     # set character offsets
    #     m.character_start_offset = mjson[&#34;characterStartOffset&#34;]
    #     m.character_end_offset = mjson[&#34;characterEndOffset&#34;]
    #     return m

    # def _to_document_map(self):
    #     return {self._doc_id: self.document}

    # def _set_type(self):
    #     # event mention
    #     if self.trigger != None:
    #         return Mention.EM
    #     # textbound mention
    #     elif self.trigger == None and self.arguments == None:
    #         return Mention.TBM
    #     else:
    #         return Mention.RM</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.words"><code class="name">var <span class="ident">words</span> : list[str]</code></dt>
<dd>
<div class="desc"><p>returns all tokens in mention</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def words(self) -&gt; list[str]:
  &#34;&#34;&#34;returns all tokens in mention&#34;&#34;&#34;
  return self.sentence_obj.words[self.start:self.end]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lum.clu.odin.mention.Mention.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, maybe_labels: typing.Optional[list[str]] = None, maybe_token_interval: typing.Optional[Interval] = None, maybe_sentence_index: typing.Optional[int] = None, maybe_document: typing.Optional[Document] = None, maybe_keep: typing.Optional[bool] = None, maybe_arguments: typing.Optional[<a title="lum.clu.odin.mention.Mention.Arguments" href="#lum.clu.odin.mention.Mention.Arguments">Mention.Arguments</a>] = None, maybe_paths: typing.Optional[<a title="lum.clu.odin.mention.Mention.Paths" href="#lum.clu.odin.mention.Mention.Paths">Mention.Paths</a>] = None, maybe_found_by: typing.Optional[str] = None) ‑> <a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of the model.</p>
<div class="admonition warning">
<p class="admonition-title">Deprecated</p>
<p>This method is now deprecated; use <code>model_copy</code> instead.</p>
</div>
<p>If you need <code>include</code> or <code>exclude</code>, use:</p>
<pre><code class="language-py">data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>include</code></strong></dt>
<dd>Optional set or mapping
specifying which fields to include in the copied model.</dd>
<dt><strong><code>exclude</code></strong></dt>
<dd>Optional set or mapping
specifying which fields to exclude in the copied model.</dd>
<dt><strong><code>update</code></strong></dt>
<dd>Optional dictionary of field-value pairs to override field values
in the copied model.</dd>
<dt><strong><code>deep</code></strong></dt>
<dd>If True, the values of fields that are Pydantic models will be deep copied.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A copy of the model with included, excluded and updated fields as specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(
  self,
  maybe_labels: typing.Optional[list[str]] = None,
  maybe_token_interval: typing.Optional[Interval] = None,
  maybe_sentence_index: typing.Optional[int] = None,
  maybe_document: typing.Optional[Document] = None,
  maybe_keep: typing.Optional[bool] = None,
  maybe_arguments: typing.Optional[Mention.Arguments] = None,
  maybe_paths: typing.Optional[Mention.Paths] = None,
  maybe_found_by: typing.Optional[str] = None,
) -&gt; Mention:
  return Mention(
    labels = maybe_labels or self.labels,
    token_interval = maybe_token_interval or self.token_interval,
    sentence_index = maybe_sentence_index or self.sentence_index,
    document = maybe_document or self.document,
    keep = maybe_keep or self.keep,
    arguments = maybe_arguments or self.arguments,
    paths = maybe_paths or self.paths,
    found_by = maybe_found_by or self.found_by
  )</code></pre>
</details>
</dd>
<dt id="lum.clu.odin.mention.Mention.matches"><code class="name flex">
<span>def <span class="ident">matches</span></span>(<span>self, label_or_pattern: typing.Union[str, re.Pattern]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>returns true if <code>label_or_pattern</code> matches any of the mention labels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matches(self, label_or_pattern: typing.Union[str, re.Pattern]) -&gt; bool:
  &#34;&#34;&#34;returns true if `label_or_pattern` matches any of the mention labels&#34;&#34;&#34;
  if isinstance(label_or_pattern, str):
    return label_or_pattern in self.labels
  elif isinstance(label_or_pattern, re.Pattern):
    patt = label_or_pattern
    return True if any(re.match(patt, lbl) != None for lbl in self.labels) else False
  return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lum.clu.odin.mention.RelationMention"><code class="flex name class">
<span>class <span class="ident">RelationMention</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.5/concepts/models/">https://docs.pydantic.dev/2.5/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of classvars defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The signature for instantiating the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a <code>RootModel</code>.</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The pydantic-core SchemaSerializer used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The pydantic-core SchemaValidator used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>An instance attribute with the values of extra fields from validation when
<code>model_config['extra'] == 'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>An instance attribute with the names of fields explicitly set.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Instance attribute with the values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>__init__</code> uses <code>__pydantic_self__</code> instead of the more common <code>self</code> for the first arg to
allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelationMention(Mention):
  # FIXME: ensure arguments dict is non-empt

  # TODO: implement me
  # see https://github.com/clulab/processors/blob/9f89ea7bf6ac551f77dbfdbb8eec9bf216711df4/main/src/main/scala/org/clulab/odin/Mention.scala
  @property
  def is_valid(self) -&gt; bool:
    &#34;&#34;&#34;returns true if this is a valid mention&#34;&#34;&#34;
    # args should all be from same sentence
    raise NotImplementedError
  
  # TODO: implement me
  @property
  def to_event_mention(trigger: TextBoundMention) -&gt; &#34;EventMention&#34;:
    &#34;&#34;&#34;&#34;&#34;&#34;
    # check that trigger and self have same sent and doc
    raise NotImplementedError

  # TODO: implement me
  def scatter(arg_name: str, size: int) -&gt; list[RelationMention]:
    raise NotImplementedError
  # arguments
  #   .getOrElse(argName, Nil)
  #   .combinations(size)
  #   .map(args =&gt; this + (argName -&gt; args))
  #   .toList

  # TODO: implement me
  # Create a new EventMention by removing a single argument
  def __sub__(other: typing.Any) -&gt; RelationMention:
    raise NotImplementedError
    #copy(arguments = this.arguments - argName)
    # Create a new EventMention by removing a sequence of arguments
    # def --(argNames: Seq[String]): EventMention =
    #   copy(arguments = this.arguments -- argNames)

  # TODO: implement me
  def __add__(other: typing.Any) -&gt; RelationMention:
    &#34;&#34;&#34;Create a new RelationMention by adding a key, value pair to the arguments map&#34;&#34;&#34;
    #def +(arg: (String, Seq[Mention])): RelationMention =
    #copy(arguments = this.arguments + arg)
    raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lum.clu.odin.mention.RelationMention.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.RelationMention.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="lum.clu.odin.mention.RelationMention.to_event_mention"><code class="name">var <span class="ident">to_event_mention</span> : <a title="lum.clu.odin.mention.EventMention" href="#lum.clu.odin.mention.EventMention">EventMention</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def to_event_mention(trigger: TextBoundMention) -&gt; &#34;EventMention&#34;:
  &#34;&#34;&#34;&#34;&#34;&#34;
  # check that trigger and self have same sent and doc
  raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lum.clu.odin.mention.RelationMention.scatter"><code class="name flex">
<span>def <span class="ident">scatter</span></span>(<span>arg_name: str, size: int) ‑> list[<a title="lum.clu.odin.mention.RelationMention" href="#lum.clu.odin.mention.RelationMention">RelationMention</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatter(arg_name: str, size: int) -&gt; list[RelationMention]:
  raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></b></code>:
<ul class="hlist">
<li><code><a title="lum.clu.odin.mention.Mention.char_end_offset" href="#lum.clu.odin.mention.Mention.char_end_offset">char_end_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.char_start_offset" href="#lum.clu.odin.mention.Mention.char_start_offset">char_start_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.chunks" href="#lum.clu.odin.mention.Mention.chunks">chunks</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.copy" href="#lum.clu.odin.mention.Mention.copy">copy</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.end" href="#lum.clu.odin.mention.Mention.end">end</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.endOffset" href="#lum.clu.odin.mention.Mention.endOffset">endOffset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.end_offset" href="#lum.clu.odin.mention.Mention.end_offset">end_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.entities" href="#lum.clu.odin.mention.Mention.entities">entities</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.isValid" href="#lum.clu.odin.mention.Mention.isValid">isValid</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.is_valid" href="#lum.clu.odin.mention.Mention.is_valid">is_valid</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.label" href="#lum.clu.odin.mention.Mention.label">label</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.lemmas" href="#lum.clu.odin.mention.Mention.lemmas">lemmas</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.matches" href="#lum.clu.odin.mention.Mention.matches">matches</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.norms" href="#lum.clu.odin.mention.Mention.norms">norms</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.raw" href="#lum.clu.odin.mention.Mention.raw">raw</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.start" href="#lum.clu.odin.mention.Mention.start">start</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.startOffset" href="#lum.clu.odin.mention.Mention.startOffset">startOffset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.start_offset" href="#lum.clu.odin.mention.Mention.start_offset">start_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.tags" href="#lum.clu.odin.mention.Mention.tags">tags</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.text" href="#lum.clu.odin.mention.Mention.text">text</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.words" href="#lum.clu.odin.mention.Mention.words">words</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lum.clu.odin.mention.TextBoundMention"><code class="flex name class">
<span>class <span class="ident">TextBoundMention</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.5/concepts/models/">https://docs.pydantic.dev/2.5/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of classvars defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The signature for instantiating the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a <code>RootModel</code>.</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The pydantic-core SchemaSerializer used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The pydantic-core SchemaValidator used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>An instance attribute with the values of extra fields from validation when
<code>model_config['extra'] == 'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>An instance attribute with the names of fields explicitly set.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Instance attribute with the values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>__init__</code> uses <code>__pydantic_self__</code> instead of the more common <code>self</code> for the first arg to
allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextBoundMention(Mention):

  # override from Mention
  arguments: typing.Optional[Mention.Arguments] = Field(default=None, description=&#34;A TextBoundMention has no arguments&#34;)
  paths: typing.Optional[Mention.Paths] = Field(default=None, description=&#34;A TextBoundMention has no paths&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></li>
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lum.clu.odin.mention.TextBoundMention.arguments"><code class="name">var <span class="ident">arguments</span> : Optional[dict[str, list[<a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a>]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.TextBoundMention.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.TextBoundMention.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lum.clu.odin.mention.TextBoundMention.paths"><code class="name">var <span class="ident">paths</span> : Optional[dict[str, dict[<a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a>, <a title="lum.clu.odin.synpath.SynPath" href="synpath.html#lum.clu.odin.synpath.SynPath">SynPath</a>]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></b></code>:
<ul class="hlist">
<li><code><a title="lum.clu.odin.mention.Mention.char_end_offset" href="#lum.clu.odin.mention.Mention.char_end_offset">char_end_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.char_start_offset" href="#lum.clu.odin.mention.Mention.char_start_offset">char_start_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.chunks" href="#lum.clu.odin.mention.Mention.chunks">chunks</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.copy" href="#lum.clu.odin.mention.Mention.copy">copy</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.end" href="#lum.clu.odin.mention.Mention.end">end</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.endOffset" href="#lum.clu.odin.mention.Mention.endOffset">endOffset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.end_offset" href="#lum.clu.odin.mention.Mention.end_offset">end_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.entities" href="#lum.clu.odin.mention.Mention.entities">entities</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.isValid" href="#lum.clu.odin.mention.Mention.isValid">isValid</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.is_valid" href="#lum.clu.odin.mention.Mention.is_valid">is_valid</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.label" href="#lum.clu.odin.mention.Mention.label">label</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.lemmas" href="#lum.clu.odin.mention.Mention.lemmas">lemmas</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.matches" href="#lum.clu.odin.mention.Mention.matches">matches</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.norms" href="#lum.clu.odin.mention.Mention.norms">norms</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.raw" href="#lum.clu.odin.mention.Mention.raw">raw</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.start" href="#lum.clu.odin.mention.Mention.start">start</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.startOffset" href="#lum.clu.odin.mention.Mention.startOffset">startOffset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.start_offset" href="#lum.clu.odin.mention.Mention.start_offset">start_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.tags" href="#lum.clu.odin.mention.Mention.tags">tags</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.text" href="#lum.clu.odin.mention.Mention.text">text</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.words" href="#lum.clu.odin.mention.Mention.words">words</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lum.clu.odin" href="index.html">lum.clu.odin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lum.clu.odin.mention.CrossSentenceMention" href="#lum.clu.odin.mention.CrossSentenceMention">CrossSentenceMention</a></code></h4>
<ul class="">
<li><code><a title="lum.clu.odin.mention.CrossSentenceMention.anchor" href="#lum.clu.odin.mention.CrossSentenceMention.anchor">anchor</a></code></li>
<li><code><a title="lum.clu.odin.mention.CrossSentenceMention.model_config" href="#lum.clu.odin.mention.CrossSentenceMention.model_config">model_config</a></code></li>
<li><code><a title="lum.clu.odin.mention.CrossSentenceMention.model_fields" href="#lum.clu.odin.mention.CrossSentenceMention.model_fields">model_fields</a></code></li>
<li><code><a title="lum.clu.odin.mention.CrossSentenceMention.neighbor" href="#lum.clu.odin.mention.CrossSentenceMention.neighbor">neighbor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lum.clu.odin.mention.EventMention" href="#lum.clu.odin.mention.EventMention">EventMention</a></code></h4>
<ul class="two-column">
<li><code><a title="lum.clu.odin.mention.EventMention.arguments" href="#lum.clu.odin.mention.EventMention.arguments">arguments</a></code></li>
<li><code><a title="lum.clu.odin.mention.EventMention.model_config" href="#lum.clu.odin.mention.EventMention.model_config">model_config</a></code></li>
<li><code><a title="lum.clu.odin.mention.EventMention.model_fields" href="#lum.clu.odin.mention.EventMention.model_fields">model_fields</a></code></li>
<li><code><a title="lum.clu.odin.mention.EventMention.paths" href="#lum.clu.odin.mention.EventMention.paths">paths</a></code></li>
<li><code><a title="lum.clu.odin.mention.EventMention.scatter" href="#lum.clu.odin.mention.EventMention.scatter">scatter</a></code></li>
<li><code><a title="lum.clu.odin.mention.EventMention.to_relation_mention" href="#lum.clu.odin.mention.EventMention.to_relation_mention">to_relation_mention</a></code></li>
<li><code><a title="lum.clu.odin.mention.EventMention.trigger" href="#lum.clu.odin.mention.EventMention.trigger">trigger</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lum.clu.odin.mention.Mention" href="#lum.clu.odin.mention.Mention">Mention</a></code></h4>
<ul class="two-column">
<li><code><a title="lum.clu.odin.mention.Mention.Arguments" href="#lum.clu.odin.mention.Mention.Arguments">Arguments</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.Paths" href="#lum.clu.odin.mention.Mention.Paths">Paths</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.arguments" href="#lum.clu.odin.mention.Mention.arguments">arguments</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.char_end_offset" href="#lum.clu.odin.mention.Mention.char_end_offset">char_end_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.char_start_offset" href="#lum.clu.odin.mention.Mention.char_start_offset">char_start_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.chunks" href="#lum.clu.odin.mention.Mention.chunks">chunks</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.copy" href="#lum.clu.odin.mention.Mention.copy">copy</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.document" href="#lum.clu.odin.mention.Mention.document">document</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.end" href="#lum.clu.odin.mention.Mention.end">end</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.endOffset" href="#lum.clu.odin.mention.Mention.endOffset">endOffset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.end_offset" href="#lum.clu.odin.mention.Mention.end_offset">end_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.entities" href="#lum.clu.odin.mention.Mention.entities">entities</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.found_by" href="#lum.clu.odin.mention.Mention.found_by">found_by</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.isValid" href="#lum.clu.odin.mention.Mention.isValid">isValid</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.is_valid" href="#lum.clu.odin.mention.Mention.is_valid">is_valid</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.keep" href="#lum.clu.odin.mention.Mention.keep">keep</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.label" href="#lum.clu.odin.mention.Mention.label">label</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.labels" href="#lum.clu.odin.mention.Mention.labels">labels</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.lemmas" href="#lum.clu.odin.mention.Mention.lemmas">lemmas</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.matches" href="#lum.clu.odin.mention.Mention.matches">matches</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.model_config" href="#lum.clu.odin.mention.Mention.model_config">model_config</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.model_fields" href="#lum.clu.odin.mention.Mention.model_fields">model_fields</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.norms" href="#lum.clu.odin.mention.Mention.norms">norms</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.paths" href="#lum.clu.odin.mention.Mention.paths">paths</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.raw" href="#lum.clu.odin.mention.Mention.raw">raw</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.sentenceObj" href="#lum.clu.odin.mention.Mention.sentenceObj">sentenceObj</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.sentence_index" href="#lum.clu.odin.mention.Mention.sentence_index">sentence_index</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.sentence_obj" href="#lum.clu.odin.mention.Mention.sentence_obj">sentence_obj</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.start" href="#lum.clu.odin.mention.Mention.start">start</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.startOffset" href="#lum.clu.odin.mention.Mention.startOffset">startOffset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.start_offset" href="#lum.clu.odin.mention.Mention.start_offset">start_offset</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.tags" href="#lum.clu.odin.mention.Mention.tags">tags</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.text" href="#lum.clu.odin.mention.Mention.text">text</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.token_interval" href="#lum.clu.odin.mention.Mention.token_interval">token_interval</a></code></li>
<li><code><a title="lum.clu.odin.mention.Mention.words" href="#lum.clu.odin.mention.Mention.words">words</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lum.clu.odin.mention.RelationMention" href="#lum.clu.odin.mention.RelationMention">RelationMention</a></code></h4>
<ul class="">
<li><code><a title="lum.clu.odin.mention.RelationMention.model_config" href="#lum.clu.odin.mention.RelationMention.model_config">model_config</a></code></li>
<li><code><a title="lum.clu.odin.mention.RelationMention.model_fields" href="#lum.clu.odin.mention.RelationMention.model_fields">model_fields</a></code></li>
<li><code><a title="lum.clu.odin.mention.RelationMention.scatter" href="#lum.clu.odin.mention.RelationMention.scatter">scatter</a></code></li>
<li><code><a title="lum.clu.odin.mention.RelationMention.to_event_mention" href="#lum.clu.odin.mention.RelationMention.to_event_mention">to_event_mention</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lum.clu.odin.mention.TextBoundMention" href="#lum.clu.odin.mention.TextBoundMention">TextBoundMention</a></code></h4>
<ul class="">
<li><code><a title="lum.clu.odin.mention.TextBoundMention.arguments" href="#lum.clu.odin.mention.TextBoundMention.arguments">arguments</a></code></li>
<li><code><a title="lum.clu.odin.mention.TextBoundMention.model_config" href="#lum.clu.odin.mention.TextBoundMention.model_config">model_config</a></code></li>
<li><code><a title="lum.clu.odin.mention.TextBoundMention.model_fields" href="#lum.clu.odin.mention.TextBoundMention.model_fields">model_fields</a></code></li>
<li><code><a title="lum.clu.odin.mention.TextBoundMention.paths" href="#lum.clu.odin.mention.TextBoundMention.paths">paths</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>